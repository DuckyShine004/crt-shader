#include "engine/engine.hpp"

#include "manager/shader_manager.hpp"

using namespace engine::entity;

using namespace manager;

namespace engine {

void Engine::initialise() {
    this->_camera.update_projection();

    this->_quads.emplace_back(0.0f, 0.0f, 0.0f, 2.0f, 2.0f);
    this->_spheres.emplace_back();

    for (Quad &quad : this->_quads) {
        quad.get_mesh().upload();
    }

    this->_crt.get_mesh().upload();

    // WARN: scene post processing here
    glGenFramebuffers(1, &this->_fbo);
    glBindFramebuffer(GL_FRAMEBUFFER, this->_fbo);

    glGenTextures(1, &this->_texture);
    glBindTexture(GL_TEXTURE_2D, this->_texture);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, 1280, 720, 0, GL_RGB, GL_UNSIGNED_BYTE, nullptr);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, this->_texture, 0);

    glGenRenderbuffers(1, &this->_rbo);
    glBindRenderbuffer(GL_RENDERBUFFER, this->_rbo);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 1280, 720);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, this->_rbo);

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void Engine::update(GLFWwindow *window, float delta_time) {
    this->_camera.update(window, delta_time);
}

void Engine::render() {
    glBindFramebuffer(GL_FRAMEBUFFER, this->_fbo);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    Shader &scene = ShaderManager::get_instance().get_shader("scene");

    scene.use();

    this->_camera.upload_model_view_projection(scene);
    this->_camera.upload_position(scene);

    scene.set_vector3f("light.direction", glm::vec3(1.0f));

    scene.set_vector3f("light.ambient", glm::vec3(0.1f));
    scene.set_vector3f("light.diffuse", glm::vec3(0.8f));
    scene.set_vector3f("light.specular", glm::vec3(1.0f));

    for (Sphere &sphere : this->_spheres) {
        sphere.render(scene);
    }

    for (Quad &quad : this->_quads) {
        quad.render(scene);
    }

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glClear(GL_COLOR_BUFFER_BIT);

    Shader &crt = ShaderManager::get_instance().get_shader("crt");

    crt.use();

    crt.set_integer("u_scene", 0);

    crt.set_float("u_brightness", 1.0f);
    crt.set_float("u_vignette_opacity", 1.0f);
    crt.set_float("u_vignette_roundness", 1.0f);

    crt.set_vector2f("u_curvature", 4.0f, 4.0f);
    crt.set_vector2f("u_resolution", 1280.0f, 720.0f);
    crt.set_vector2f("u_scanline_opacity", 0.25f, 0.25f);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, this->_texture);

    this->_crt.render(crt);
}

camera::Camera &Engine::get_camera() {
    return this->_camera;
}

} // namespace engine
